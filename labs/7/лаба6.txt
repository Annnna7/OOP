Шаг дискретизации, также известный как интервал дискретизации, определяет разницу во времени между двумя последовательными измерениями или отсчетами сигнала. Этот шаг измеряется во временной единице, такой как секунда. Шаг дискретизации определяет, насколько часто сигнал анализируется и сохраняется в дискретной форме.

NullPointerException s-это исключения, возникающие при попытке использовать ссылку, которая не указывает ни на какое место в памяти (null), как если бы она ссылалась на объект. Вызов метода по нулевой ссылке или попытка доступа к полю нулевой ссылки вызовет исключение NullPointerException.

Список ситуаций , вызывающих NullPointerException возникновение
Вот все ситуации, в которых NullPointerException возникает, которые непосредственно * упоминаются в спецификации языка Java:
1. Доступ (т. е. получение или настройка) к полю экземпляра нулевой ссылки. (статические поля не учитываются!)
2. Вызов метода экземпляра нулевой ссылки. (статические методы не учитываются!)
throw null;
3. Доступ к элементам массива null.
4. Синхронизация по null - synchronized (someNullReference) { ... }
5. Любой оператор целого числа / с плавающей запятой может выдавать a NullPointerException , если один из его операндов является пустой ссылкой в штучной упаковке
6. Преобразование при распаковке выдаетNullPointerException, если значение в штучной упаковке равно null.
7. Вызов super по нулевой ссылке выдает NullPointerException. Если вы в замешательстве, речь идет о вызовах конструктора суперкласса:
class Outer {
    class Inner {}
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner(Outer o) { 
        o.super(); // if o is null, NPE gets thrown
    }
}
8. Использование for (element : iterable) цикла для перебора нулевой коллекции / массива.
9. switch (foo) { ... } (независимо от того, является ли это выражением или оператором) может выдавать a, NullPointerException когда foo равно null.
10. foo.new SomeInnerClass() выдает a, NullPointerException когда foo равно null.
11. Ссылки на методы вида name1::name2 or primaryExpression::name выдает NullPointerException при вычислении, когда name1 or primaryExpression принимает значение null.
в примечании из JLS здесь говорится, что, someInstance.someStaticMethod() не генерирует NPE, потому что someStaticMethod является статическим, но someInstance::someStaticMethod все равно генерирует NPE!

Метод notify () подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll () заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait (), то при вызове notify () или notifyAll () ничего не происходит.

Метод interrupt. Еще один способ вызова завершения или прерывания потока представляет метод interrupt (). Вызов этого метода устанавливает у потока статус, что он прерван. Сам метод возвращает true, если поток может быть прерван, в ином случае возвращается false. При этом сам вызов этого метода НЕ завершает поток, он только устанавливает статус: в частности, метод isInterrupted () класса Thread будет возвращать значение true.

Java Thread Join — метод, который может быть использован для того, чтобы приостановить выполнение текущего потока до тех пор, пока другой поток не закончит свое выполнение.

Синхронизаторы – вспомогательные утилиты для синхронизации потоков, которые дают возможность разработчику регулировать и/или ограничивать работу потоков и предоставляют более высокий уровень абстракции, чем основные примитивы языка (мониторы).
Semaphore
Синхронизатор Semaphore реализует шаблон синхронизации Семафор. Чаще всего, семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (Semaphore(int permits) или Semaphore(int permits, boolean fair)) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.
Доступ управляется с помощью счётчика: изначально значение счётчика равно int permits, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока (в качестве примера из жизни с permits = 1, можно привести очередь в кабинет в поликлинике: когда пациент покидает кабинет, мигает лампа, и заходит следующий пациент).

Счетный семафор. Концептуально семафор поддерживает набор разрешений. Каждый acquire() блокирует при необходимости до тех пор, пока не будет получено разрешение, а затем забирает его. Каждый из них release() добавляет разрешение, потенциально освобождая блокирующего приобретателя. Однако никакие фактические объекты разрешения не используются; Semaphore просто подсчитывает доступное количество и действует соответствующим образом.
Семафоры часто используются для ограничения количества потоков, которые не могут получить доступ к какому-либо (физическому или логическому) ресурсу.
Перед получением элемента каждый поток должен получить разрешение от семафора, гарантирующее, что элемент доступен для использования. Когда поток завершает работу с элементом, он возвращается обратно в пул, а семафору возвращается разрешение, позволяющее другому потоку получить этот элемент. Обратите внимание, что блокировка синхронизации не удерживается при acquire() вызове, поскольку это предотвратило бы возврат элемента в пул. Семафор инкапсулирует синхронизацию, необходимую для ограничения доступа к пулу, отдельно от любой синхронизации, необходимой для поддержания согласованности самого пула.

Семафор, инициализированный одним и используемый таким образом, что у него доступно не более одного разрешения, может служить блокировкой взаимного исключения. Это более широко известно как двоичный семафор, потому что у него есть только два состояния: доступно одно разрешение или доступно ноль разрешений. При использовании таким образом двоичный семафор обладает свойством (в отличие от многих Lock реализаций), что "блокировка" может быть снята потоком, отличным от владельца (поскольку семафоры не имеют понятия собственности). Это может быть полезно в некоторых специализированных контекстах, таких как восстановление взаимоблокировки.
Конструктор для этого класса необязательно принимает параметр справедливости. Если установлено значение false, этот класс не дает никаких гарантий относительно порядка, в котором потоки получают разрешения. В частности, разрешено прерывание, то есть потоку, вызывающему поток, acquire() может быть выделено разрешение перед потоком, который ожидал - логически новый поток помещает себя во главе очереди ожидающих потоков. Когда для параметра справедливость установлено значение true, семафор гарантирует, что потоки, вызывающие любой из acquire методов, выбираются для получения разрешений в том порядке, в котором был обработан их вызов этих методов (первый вход-первый выход; FIFO). Обратите внимание, что порядок FIFO обязательно применяется к определенным внутренним точкам выполнения в рамках этих методов. Таким образом, один поток может вызывать acquire перед другим, но достигать точки упорядочения после другого, и аналогично при возврате из метода. Также обратите внимание, что несвоевременные tryAcquire методы не учитывают настройку справедливости, но будут принимать любые доступные разрешения.
Как правило, семафоры, используемые для управления доступом к ресурсам, должны быть инициализированы как fair, чтобы гарантировать, что ни один поток не будет лишен доступа к ресурсу. При использовании семафоров для других видов управления синхронизацией преимущества в пропускной способности от несправедливого упорядочивания часто перевешивают соображения справедливости.
Этот класс также предоставляет удобные методы для acquire и release получения нескольких разрешений одновременно. Остерегайтесь повышенного риска бессрочной отсрочки, когда эти методы используются без значения справедливости true.
Эффекты согласованности памяти: действия в потоке перед вызовом метода "release", такие как release() happen, перед действиями после успешного "получения", такими как acquire() в другом потоке.

Семафор управляет доступом к общему ресурсу с помощью счетчика. Если счетчик больше нуля, то доступ разрешен. Если он равен нулю, то доступ запрещен. Счетчик считает разрешения, разрешающие доступ к общему ресурсу. Таким образом, для доступа к ресурсу потоку должно быть предоставлено разрешение от семафора.

Работа семафора

В общем случае, чтобы использовать семафор, поток, который хочет получить доступ к общему ресурсу, пытается получить разрешение.
Если счетчик семафора больше нуля, то поток получает разрешение, которое приводит к уменьшению количества семафоров.
В противном случае поток будет заблокирован до тех пор, пока не будет получено разрешение.
Когда потоку больше не нужен доступ к общему ресурсу, он освобождает разрешение, что приводит к увеличению количества семафоров.
Если есть другой поток, ожидающий разрешения, то этот поток получит разрешение в это время.
Java предоставляет класс Semaphore в пакете java.util.concurrent, который реализует этот механизм, поэтому вам не нужно реализовывать свои собственные семафоры.

В классе Semaphore есть два конструктора.
Semaphore(int num)
Semaphore(int num, boolean how)
Здесь num указывает начальное количество разрешений. Таким образом, оно определяет количество потоков, которые могут обращаться к общему ресурсу одновременно. Если он один, то только один поток может получить доступ к ресурсу в любой момент времени. По умолчанию всем ожидающим потокам предоставляется разрешение в неопределенном порядке. Установив для как значение true, вы можете гарантировать, что ожидающим потокам будет предоставлено разрешение в том порядке, в котором они запросили доступ.

Мы можем использовать семафор для блокировки доступа к ресурсу, каждый поток, который хочет использовать этот ресурс, должен сначала вызвать acquire( ) перед обращением к ресурсу для получения блокировки. Когда поток завершает работу с ресурсом, он должен вызвать release( ), чтобы снять блокировку.

Класс SimpleGenerator должен реализовывать интерфейс Runnable, получать в конструкторе и сохранять в своё поле ссылку на объект типа Task, а в методе run() в цикле должны формироваться задачи и заноситься в полученный объект задания, а также выводиться сообщения в консоль.
Класс SimpleIntegrator должен реализовывать интерфейс Runnable, получать в конструкторе и сохранять в своё поле ссылку на объект типа Task, а в методе run() в цикле должны решаться задачи, данные для которых берутся из полученного объекта задания, а также выводиться сообщения в консоль.

Класс Generator должен расширять класс Thread, получать в конструкторе и сохранять в свои поля ссылки на объект типа Task и на объект семафора, а в методе run() должны выполняться те же действия, что и в предыдущей версии генерирующего класса.
Класс Integrator должен расширять класс Thread, получать в конструкторе и сохранять в свои поля ссылки на объект типа Task и на объект семафора, а в методе run() должны выполняться те же действия, что и в предыдущей версии интегрирующего класса.
Отличие этих классов от предыдущих версий должно заключаться в том, что вместо средств синхронизации в методах run() должны использоваться возможности семафора.


Runnable - это интерфейс описывающий метод Run, с помощью которого Вы можете передать в другой класс свой код для выполнения. И он никак не связан с Thread, в том смысле, что он не несёт никакой скрытой функциональности. Для выполнения какого-то кода в потоке класс Thread просто использует этот интерфейс как уровень абстракции.

Синхронизация Java используется для того, чтобы с помощью некоторого метода синхронизации убедиться, что только один поток может получить доступ к ресурсу в данный момент времени.
Синхронизированный блок в Java синхронизируется с некоторым объектом. Все синхронизированные блоки синхронизируются с одним и тем же объектом, и внутри них одновременно может выполняться только один поток. Все другие потоки, пытающиеся войти в синхронизированный блок, блокируются до тех пор, пока поток внутри синхронизированного блока не выйдет из блока.

@Override у метода — говорит о том, что родительский метод переопределён в наследнике. Компилятор при наличии такой аннотации проверяет, не нарушены ли правила переопределения.

Поток (thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах.

Thread - это класс, некоторая надстройка над физическим потоком. Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей. Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.