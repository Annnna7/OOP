Ключевое слово super вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора;

Константа Double.POSITIVE_INFINITY содержит положительное значение бесконечности типа double. Это значение получается путем деления 1.0 на 0.0. Его строковое представление равно бесконечности. Это условное значение, и его шестнадцатеричное представление равно 7FF0000000000000. Каждая двойная переменная с этим побитовым значением содержит положительную бесконечность.

Константа Double .NEGATIVE_INFINITY содержит отрицательное значение бесконечности типа double. Это значение получается путем деления -1,0 на 0,0. Его строковое представление - -Infinity. Это значение также является условным, и его шестнадцатеричным представлением является FFF0000000000000. Каждая двойная переменная с этим побитовым значением содержит отрицательную бесконечность.

Log b по основанию а = x, a^x=b, a>0, a!=1, b>0
Областью определения логарифмической функции является множество всех положительных действительных чисел, а областью значений — множество всех действительных чисел.

В классе Log у нас есть приватное поле osn, которое хранит основание логарифма. Параметр osn передается в конструкторе.
Метод getFunctionValue принимает число, для которого нужно вычислить логарифм, и возвращает значение логарифма по заданному основанию. Он использует метод Math.log() для вычисления натурального логарифма и делит результат на Math.log(osn), чтобы получить значение логарифма по заданному основанию.

Абстрактный класс — класс, реализация которого описана не полностью. Понятие, в некотором смысле родственное интерфейсу, с разницей в том, что реализация интерфейса вообще не описана. Абстрактный класс может иметь поля, методы и абстрактные методы — методы, реализация которых не описана. public abstract class. ArrayContainer implements.

Extends – ключевое слово, применяемое к классам для указания родительской сущности. В Java, в отличие от, например, C++ родитель может быть только один. 

Метод double getFunctionValue(double x) должен возвращать значение функции в точке x, если эта точка лежит в области определения функции. В противном случае метод должен возвращать значение неопределённости. 

Implements - ключевое слово, которое используется для реализации интерфейса на языке Java.

final (модификатор полей класса) - поле не может изменять своё значение после инициализации

Композиция двух функций — это математическая операция, которая выполняется путем последовательного применения одной функции к результату другой функции. То есть результат первой функции становится входным параметром для второй функции. Обозначается композиция функций обычно как f ◦ g, где f и g — функции, которые нужно скомпоновать. Результат композиции f ◦ g (x) равен f (g (x)).

При умножении переменной x на значение scaleX происходит изменение масштаба — значение x увеличивается или уменьшается в соответствии с этим коэффициентом.

static (модификаторы полей класса) - статичность метода, то есть метод принадлежит контексту класса, а не объекта.

Math.E Свойство возвращает математическую константу e (2.718281828459045...).

Класс DataOutputStream представляет поток вывода и предназначен для записи данных примитивных типов, таких, как int, double и т.д. Для записи каждого из примитивных типов предназначен свой метод:
writeDouble(double v): записывает в поток 8-байтовое значение double
writeInt(int v): записывает в поток целочисленное значение int

Класс DataInputStream действует противоположным образом - он считывает из потока данные примитивных типов. Соответственно для каждого примитивного типа определен свой метод для считывания:
double readDouble(): считывает из потока 8-байтовое значение double

Класс PrintStream - это именно тот класс, который используется для вывода на консоль. Когда мы выводим на консоль некоторую информацию с помощью вызова System.out.println(), то тем самым мы задействует PrintStream, так как переменная out в классе System как раз и представляет объект класса PrintStream, а метод println() - это метод класса PrintStream.
Но PrintStream полезен не только для вывода на консоль. Мы можем использовать данный класс для записи информации в поток вывода.

Класс Java.io.StreamTokenizer преобразует входной поток в “токены”.Он позволяет считывать по одному токену за раз. Stream Tokenizer может распознавать числа, строки в кавычках и различные стили комментариев.

Сериализация — это процесс преобразования объекта в поток байтов для сохранения или передачи в память, базу данных или файл. Эта операция предназначена для того, чтобы сохранить состояния объекта для последующего воссоздания при необходимости. Обратный процесс называется десериализацией.

Так как механизм сериализации связан с базовой системой ввода/вывода и переводит объект в поток байтов, для его выполнения необходимо создать выходной поток OutputStream, упаковать его в ObjectOutputStream и вызвать метод writeObject(). Для восстановления объекта нужно упаковать InputStream в ObjectInputStream и вызвать метод readObject().
В процессе сериализации вместе с сериализуемым объектом сохраняется его граф объектов. Т.е. все связанные с этим объектом, объекты других классов так же будут сериализованы вместе с ним.

flush()просто проверяет, что все буферизованные данные записаны на диск (в данном случае - в более общем плане, сброшены через любой используемый вами канал ввода-вывода). После этого вы все еще можете выполнять запись в поток (или writer).
close() сбрасывает данные и указывает, что данных больше нет. Это закрывает все дескрипторы файлов, сокеты или что-то еще. После этого вы больше не сможете выполнять запись в поток (или writer).
Обратите внимание, что без вызовов flush() данные по-прежнему быть помещены в буферизацию. , ,
close() обычно вызывает flush() также, но недавно мне было указано, что в некоторых реализациях JDK любые исключения, вызванные сбросом как частью закрытия, проглатываются :(

Java IOExceptions - это исключения ввода-вывода (I / O), которые возникают всякий раз, когда операция ввода-вывода завершается неудачно или интерпретируется.

RuntimeException – это непроверенные исключения. Они возникают во время выполнения приложения. К таким исключениям относится, например, NullPointerException. Они не требуют обязательного заключения в блок try-catch. Когда RuntimeException возникает, это свидетельствует о ошибке, допущенной программистом (неинициализированный объект, выход за пределы массива и т.д.). Поэтому данное исключение не нужно обрабатывать, а нужно исправлять ошибку в коде, чтобы исключение вновь не возникало.

Класс Double в Java предоставляет удобный метод toString(), который преобразует значение double в соответствующее ему строковое представление.

Буферизация - Способ организации обмена данными, Метод организации обмена, в частности, ввода и вывода данных в компьютерах и других вычислительных устройствах, который подразумевает использование буфера для временного хранения данных.

Класс BufferedWriter записывает текст в поток, предварительно буферизируя записываемые символы, тем самым снижая количество обращений к физическому носителю для записи данных.
В качестве параметра он принимает поток вывода, в который надо осуществить запись. Второй параметр указывает на размер буфера.

Класс StreamTokenizer считывает поток посимвольно. Каждый из них может иметь ноль или более следующих атрибутов: пробел, буквенный, цифровой, строковую кавычку или символ комментария.

Метод nextToken() класса StringTokenizer используется для возврата следующих токенов один за другим из этого StringTokenizer.

Метод append() – обновляет значение объекта, который вызвал метод. Этот метод в Java принимает boolean, char, int, long, Strings и т.д.

Содержимое файлов при использовании интерфейса Serializable и Externalizable будет разным.

При механизме сериализации с использованием интерфейса Serializable создается двоичный файл, который содержит все поля и методы сериализуемого объекта. Файл нельзя прочитать без использования сериализации, и его содержимое непонятно для человека.

При механизме сериализации с использованием интерфейса Externalizable создается читаемый человеком файл, который представляет сериализованный объект в текстовом виде. Файл содержит только необходимые данные для восстановления объекта, а все остальные поля и методы игнорируются. Этот файл можно редактировать вручную перед десериализацией.

Основным преимуществом механизма сериализации с использованием интерфейса Serializable является его простота. Не требуется явно определять методы сериализации или десериализации, так как все это обрабатывается автоматически. Однако его недостатком является невозможность изменения содержимого файла до десериализации, а также потенциальная угроза безопасности, так как все данные объекта сохраняются полностью.

Основным преимуществом механизма сериализации с использованием интерфейса Externalizable является его гибкость. Можно явно определить, какие данные объекта будут сериализованы и десериализованы, и также можно добавить дополнительные операции с данными при сериализации и десериализации. Также этот способ позволяет читать и изменять содержимое файла перед десериализацией, что может быть полезно в некоторых случаях. Однако его недостатком является необходимость явно определять методы сериализации и десериализации, что требует дополнительного кода и может быть сложным для сложных объектов.

Итак, преимуществом Serializable является простота использования, в то время как Externalizable предлагает большую гибкость и контроль над сериализацией. Выбор между ними зависит от конкретных требований и ограничений вашего проекта.

