Ассоциация - это отношение между двумя отдельными классами, которое устанавливается через их объекты. Ассоциация может быть один-к-одному, один-ко-многим, многие-к-одному, многие-ко-многим. В объектно-ориентированном программировании объект взаимодействует с другим объектом для использования функциональности и сервисов, предоставляемых этим объектом. Композиция и агрегация - это две формы ассоциации.
Агрегация - это особая форма ассоциации; это однонаправленная ассоциация, то есть односторонняя связь. Например, в отделе могут быть студенты, но обратное невозможно и, следовательно, однонаправлено по своей природе.
При агрегировании обе записи могут сохраняться по отдельности, что означает, что завершение работы одной сущности не повлияет на другую сущность.

Дженерики (обобщения) — это особые средства языка Java для реализации обобщённого программирования: особого подхода к описанию данных и алгоритмов, позволяющего работать с различными типами данных без изменения их описания.
Дженерики означают параметризованные типы. Идея состоит в том, чтобы разрешить тип (Integer, String, ... и т.д., А также определяемые пользователем типы) быть параметром для методов, классов и интерфейсов. Используя Generics, можно создавать классы, работающие с различными типами данных. Такая сущность, как класс, интерфейс или метод, который работает с параметризованным типом, является универсальной сущностью.

Iterable представляет собой простое представление ряда однородных элементов, которые могут повторяться определенное количество раз. Он не имеет никакого итерационного состояния, такого как "текущий элемент". Вместо этого он имеет один метод, который создает Iterator.
Iterator - объект с итерационным состоянием. Он позволяет вам проверить, есть ли у него больше элементов с помощью метода hasNext() и перейти к следующему элементу (если он есть) с помощью метода next().
Как правило, Iterable должен иметь возможность выдавать любое количество допустимых Iterator-ов.

Итератор (Iterable): Класс, который управляет итерацией по итерируемому. То есть, он отслеживает, где мы находимся в текущей итерации, и знает, что представляет собой следующий элемент и как его получить. Чтобы сделать объект итерабельным, он должен возвращать объект Iterator. Чтобы обеспечить выполнение этого контракта, необходимо использовать интерфейс Iterable. Он содержит метод с именем iterator () и возвращает Iterator.

Методы, которые должен имплементировать Iterator
boolean hasNext() — если в итерируемом объекте (пока что это Collection) остались еще значение — метод вернет true, если значения кончились false.
E next() — возвращает следующий элемент коллекции (объекта). Если элементов больше нет (не было проверки hasNext(), а мы вызвали next(), достигнув конца коллекции), метод бросит NoSuchElementException.
void remove() — удалит элемент, который был в последний раз получен методом next(). Метод может бросить:
UnsupportedOperationException, если данный итератор не поддерживает метод remove() (в случае с read-only коллекциями, например)
IllegalStateException, если метод next() еще не был вызван, или если remove() уже был вызван после последнего вызова next().

Шаблон итератора - отличный шаблон для обеспечения навигации, не раскрывая структуру объекта.

Дизайн: шаблон итератора
Это шаблон проектирования на основе интерфейса. К какому бы объекту вы ни хотели выполнить итерацию, он предоставит метод для возврата экземпляра итератора из него.
В способе получения экземпляра итератора используется шаблон метода на основе фабрики.
Каждый итератор разработан таким образом, что он независим от другого.
Итераторы также быстро завершаются сбоем. Быстрый сбой означает, что итераторы не могут изменить базовый объект без возникновения ошибки.

Заключение:
Итератор - это эффективный способ обхода объекта.
Скрывает алгоритм от клиента, так что простота для вашего клиента содержится в алгоритме, который вы описали в контейнере, для которого вы создаете итератор
Помогает нам упростить работу с этим клиентом.
Помогает нам воспользоваться преимуществами синтаксиса for each, который определенно упрощает итерацию по этому объекту в цикле for each.

Анонимные классы позволяют вам сделать ваш код более кратким. Они позволяют вам объявлять и создавать экземпляры класса одновременно. Они похожи на локальные классы, за исключением того, что у них нет имени. Используйте их, если вам нужно использовать локальный класс только один раз.
Как упоминалось ранее, анонимный класс - это выражение. Синтаксис выражения анонимного класса подобен вызову конструктора, за исключением того, что определение класса содержится в блоке кода.
Выражение анонимного класса состоит из следующего:
1) new Оператор
2)Имя интерфейса для реализации или класса для расширения. В этом примере анонимный класс реализует интерфейс HelloWorld.
3) Круглые скобки, содержащие аргументы конструктора, точно так же, как обычное выражение для создания экземпляра класса. Примечание: при реализации интерфейса конструктора нет, поэтому вы используете пустую пару круглых скобок, как в этом примере.
4) Тело, которое является телом объявления класса. Более конкретно, в теле разрешены объявления методов, но не операторов.
Поскольку определение анонимного класса является выражением, оно должно быть частью инструкции. 

Итератор - это простой способ разрешить некоторым циклическим путем собирать данные без возможности изменения элементов коллекции (хотя и с возможностью их удаления).

Можно рассмотреть эти 2 интерфейса еще с одной стороны:

1. Итерируемый (Iterable): Класс, который можно повторить. То есть тот, у которого есть понятие "принесите мне первое, теперь следующее, и так далее, пока мы не закончим".
2. Итератор (Iterable): Класс, который управляет итерацией по итерируемому. То есть, он отслеживает, где мы находимся в текущей итерации, и знает, что представляет собой следующий элемент и как его получить.
Чтобы сделать объект итерабельным, он должен возвращать объект Iterator. Чтобы обеспечить выполнение этого контракта, необходимо использовать интерфейс Iterable. Он содержит метод с именем iterator() и возвращает Iterator. Следовательно, любой класс, реализующий Iterable, может вернуть Iterator.

 метод getClass() , который используется для доступа к метаданным о классе объекта, с которым вы работаете.
метод объекта getClass() возвращает экземпляр класса Class, который содержит информацию о классе, из которого был вызван getClass()

Java использует инстанцирование для создания новых экземпляров или объектов, которые используются в программе.
Под созданием экземпляра мы подразумеваем акт вызова конструктора класса, который создает экземпляр или объект этого класса. Во время этого процесса для объекта выделяется память и возвращается ссылка на него. По сути, класс действует как схема, и создание экземпляра создает объект на основе этой схемы.

Это шаблон творческого проектирования, который рассказывает о создании объекта. Шаблон проектирования фабрики гласит, что определяет интерфейс (интерфейс Java или абстрактный класс) для создания объекта и позволяет подклассам решать, какой класс создавать. Заводской метод в интерфейсе позволяет классу отложить создание экземпляра до одного или нескольких конкретных подклассов. Поскольку эти шаблоны проектирования говорят о создании экземпляра объекта, он подпадает под категорию шаблонов творческого проектирования. Если мы обратим внимание на название, Фабричный метод это означает, что существует метод, который является фабрикой, и в целом фабрики задействованы в создании материалов, и вот с помощью этого создается объект. Это один из лучших способов создания объекта, в котором логика создания объекта скрыта от клиента. Теперь давайте посмотрим на реализацию.
Реализация: 
1. Определите заводской метод внутри интерфейса.
2. Пусть подкласс реализует приведенный выше заводской метод и решает, какой объект создавать.
3. В Java конструкторы не являются полиморфными, но, разрешая подклассу создавать объект, мы добавляем полиморфное поведение к созданию экземпляра. Короче говоря, мы пытаемся достичь псевдо полиморфизм, позволяя подкласса, чтобы решить, что именно создавать, а значит, этот фабричный метод также называется виртуальный конструктор.

Класс Constructor используется для управления метаданными конструктора, такими как имя конструкторов, типы параметров конструкторов и модификаторы доступа к конструкторам. Мы можем проверять конструкторы классов и создавать экземпляры объектов во время выполнения. Массив Constructor[] будет иметь один экземпляр конструктора для каждого открытого конструктора, объявленного в классе.
Чтобы получить объекты конструктора, можно получить объект класса конструктора из объекта класса.

Метод getConstructors() в java.lang.Class class используется для получения конструкторов этого класса, которые являются общедоступными конструкторами. Метод возвращает конструкторы этого класса в виде массива объектов конструктора.
Метод java.lang.reflect.Метод.getParameterCount() класса Method возвращает количество параметров, объявленных для объекта method.
Метод newInstance() класса Constructor используется для создания и инициализации нового экземпляра этого конструктора, при этом параметры инициализации передаются в качестве параметра этому методу. Каждый параметр развертывается так, чтобы соответствовать формальным параметрам примитива, и как примитивные, так и ссылочные параметры подлежат преобразованиям при вызове метода по мере необходимости.
Если количество формальных параметров конструктора равно 0, предоставленный параметр имеет длину 0 или null. Если конструктор завершается нормально, возвращает только что созданный и инициализированный экземпляр.

getDeclaredConstructors(): Один из них может получить все конструкторы в соответствующем классе независимо от ключевого слова public .
Метод getDeclaredConstructor() java.lang.Класс class используется для получения указанного конструктора этого класса с указанным типом параметра. Метод возвращает указанный конструктор этого класса в виде объекта Constructor.
Параметр: Этот конструктор принимает тип параметра parameters, который является массивом типа параметра для указанного конструктора.
Возвращаемое значение: Этот метод возвращает указанный конструктор этого класса в виде объектов конструктора.

getName(): можно получить имя соответствующего конструктора.
getModifiers(): это возвращает модификаторы языка Java для конструктора, представленного этим объектом Constructor в виде целого числа. Класс-модификатор должен использоваться для декодирования модификаторов.
getParameterTypes(): Это возвращает типы параметров конкретного конструктора.

Java API (Application Programming Interface — интерфейс прикладного программирования) — это набор классов, сгруппированных в пакеты, разработанных Sun Microsystems для работы с языком Java.
Отражение - это API, который используется для проверки или изменения поведения методов, классов и интерфейсов во время выполнения. Необходимые классы для отражения предоставляются в пакете java.lang.reflect, который необходим для понимания отражения. 

Отражение дает нам информацию о классе, к которому принадлежит объект, а также о методах этого класса, которые могут быть выполнены с помощью объекта.
Благодаря отражению мы можем вызывать методы во время выполнения независимо от используемого с ними спецификатора доступа.

Отражение можно использовать для получения информации о классе, конструкторах и методах, как показано ниже, в табличном формате, как показано на рисунке:

Класс	Метод getClass() используется для получения имени класса, к которому принадлежит объект.
Конструкторы	Метод getConstructors() используется для получения открытых конструкторов класса, к которому принадлежит объект.
Методы	Метод GetMethods() используется для получения открытых методов класса, к которому принадлежит объект.
Мы можем вызвать метод с помощью отражения, если знаем его имя и типы параметров. Для этой цели мы используем два метода, как описано ниже, прежде чем двигаться дальше следующим образом:

getDeclaredMethod()
вызвать()
Метод 1: getDeclaredMethod(): IT создает объект вызываемого метода.

Синтаксис: Синтаксис для этого метода

Class.getDeclaredMethod(name, parametertype)
Параметры:

Имя метода, объект которого должен быть создан
Массив объектов класса
Метод 2: invoke(): он вызывает метод класса, во время выполнения которого мы используем следующий метод.

Синтаксис: 

Method.invoke(Object, parameter)
Совет: Если метод класса не принимает никаких параметров, то в качестве аргумента передается null.

Примечание: С помощью отражения мы можем получить доступ к закрытым переменным и методам класса с помощью объекта его класса и вызвать метод, используя объект, как описано выше. Для этой цели мы используем следующие два метода.

Метод 3: Class.getDeclaredField(имя_поля): используется для получения закрытого поля. Возвращает объект типа Field для указанного имени поля.

Метод 4: Field.setAccessible(true): Позволяет получить доступ к полю независимо от модификатора доступа, используемого с полем.

Важные наблюдения, сделанные на основе Reflection API
Возможности расширения: Приложение может использовать внешние, определяемые пользователем классы, создавая экземпляры объектов расширения, используя их полные имена.
Инструменты отладки и тестирования: Отладчики используют свойство отражения для проверки закрытых членов классов.
Издержки производительности: Отражающие операции имеют более низкую производительность, чем их неотражающие аналоги, и их следует избегать в разделах кода, которые часто вызываются в приложениях, чувствительных к производительности.
Раскрытие внутренних компонентов: Отражающий код нарушает абстракции и, следовательно, может изменить поведение при обновлении платформы.

Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.

Сам же механизм рефлексии позволяет обрабатывать типы, отсутствующие при компиляции, но появившиеся во время выполнения программы. Рефлексия и наличие логически целостной модели выдачи информации об ошибках дает возможность создавать корректный динамический код.
        
Иначе говоря, понимание принципов работы рефлексии в java открывает перед вами ряд удивительных возможностей. Вы буквально можете жонглировать классами и их составляющими.
Reflection API. Рефлексия. Темная сторона Java - 2
Вот основной список того, что позволяет рефлексия: 
Узнать/определить класс объекта;
Получить информацию о модификаторах класса, полях, методах, константах, конструкторах и суперклассах;
Выяснить, какие методы принадлежат реализуемому интерфейсу/интерфейсам;
Создать экземпляр класса, причем имя класса неизвестно до момента выполнения программы;
Получить и установить значение поля объекта по имени;
Вызвать метод объекта по имени.
Рефлексия используется практически во всех современных технологиях Java. Сложно себе представить, могла бы Java, как платформа, достигнуть такого огромного распространения без рефлексии. Скорее всего не смогла бы. 


